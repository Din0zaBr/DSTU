import itertools as iter
import string
from itertools import chain

massT = str(input("Множество терминалов: ")).split()
massN = str(input("Множество нетерминалов: ")).split()
S = str(input("Введите стартовый символ: "))
n = int(input("Количество правил: "))
print("Введите правила по типу: Aa = Rpppp\n"
      "Если из левой части есть несколько переходов, пропишите их через пробел слева\n"
      "В качестве пустой цепочки выступает точка (.)\n")


def check_KS():
    """
        Предлагает пользователю ввести последовательность строк, представляющих контекстно-свободную грамматику.
        Анализирует каждую введенную строку и сохраняет разобранное представление в списке списков под названием `rooles`.
        Проверяет, присутствуют ли все символы в первой строке каждого ввода в заранее определенном списке под названием `massN`.
        Если какие-либо символы отсутствуют, увеличивает счетчик под названием `count`.
        Если `count` равно нулю, устанавливает строку результата равной "Введена КС-грамматика" и устанавливает флаг в 1.
        В противном случае устанавливает строку результата равной "Введенная грамматика не является КС-грамматикой" и устанавливает флаг в 0.
        Возвращает кортеж, содержащий строку результата, флаг и список `rooles`.
    """
    count = 0
    rules = []
    pravila = input().split(", ")
    for pravilo in pravila:
        current_rule = str(pravilo).split()
        a = current_rule[0]  # roole_n = ['S', '=', 'X|Y|Z'] -> 'S'
        b = current_rule[2]  # roole_n = ['S', '=', 'X|Y|Z'] -> 'X|Y|Z'
        rules.append([a, b])  # [['S', ['X|Y|Z']]]
        if a not in massT:  # Проверка, что слева д/б только терминалы
            count += 1
    if count == 0:
        rez, flag = 'Введена КС-грамматика', True
    else:
        rez, flag = "Введенная грамматика не является КС-грамматикой", False
    return rez, rules, flag


def check_exist(lst, massT, S):  # есть ли S в множестве Терминалов
    """
    Проверяет, существует ли данная строка S в списке строк massN.

    Параметры:
        lst (list): Список кортежей, каждый из которых представляет язык. Каждый кортеж содержит два списка:
                    первый список представляет нетерминальные символы, второй список - терминальные символы.
        massT (list): Список строк, представляющих все возможные терминальные символы.
        S (str): Строка, представляющая язык для проверки существования.

    Возвращает:
        str: Строка, указывающая на существование или несуществование языка. Возвращает 'Язык не существует',
             если язык не существует, и 'Язык существует', если язык существует.
    """
    N0 = []
    for i in range(len(lst)):
        for j in chain(lst[i][1], lst[i][0]):
            # print(lst[i][1], lst[i][0])
            [N0.append(x) for x in list(j) if x in massT and x not in N0]
            # print(N0)
    if S not in N0:
        return 'Язык не существует'
    else:
        return "Язык существует"


def del_useless_sym(massT, massN, lst):
    """
        Эта функция принимает три параметра: massT, massN и lst.
        Она удаляет ненужные символы из переданных списков и возвращает обновленные списки.
        Затем определяется вложенная функция cycle_el(), которая принимает список mass и итерируется по lst,
        чтобы найти элементы, имеющие подмножества massT и mass.
        Функция инициализирует массив mass значением '.' и вызывает cycle_el() для обновления массива mass.
        Затем вызывается cycle_el() еще раз для обновления Ni.
        Процесс продолжается до тех пор, пока N1 и Ni не будут равны.
        Затем функция создает новый список N, фильтруя элементы из massN, которые находятся в Ni.
        Если длина списка N не равна 0, функция создает новый список r и итерируется по lst, чтобы найти элементы,
        имеющие подмножества Ni, massT или '.'.
    """

    print('a) бесполезных символов')


    # S X Y Z K
    # x y z k # $
    # S
    # 5
    # S = X|Y|Z, X = x#X|x#Y|., Y = Yy$|Yz$|$|., Z = Zz$, K = Kk$|k$


    set_massT = set(massT)
    set_lst = set([x[0] for x in lst])

    set_good = list(set.intersection(set_lst, set_massT))  # ['Y', 'S', 'X', 'K', 'Z']
    print(set_good)

    # множество нетерминалов, порождающих терминальные строки, с помощью алгоритма
    # находи   всё из шага 2 алгоритма 2




    # N = [element for element in massN if element not in Ni]  # Бесполезные символы
    # if len(N) != 0:
    #     r = []  # Будущие новые правила
    #     for i in range(len(lst)):
    #         r0 = []
    #         for j in lst[i][1]:
    #             v = []
    #             [v.append(x) for x in list(j) if x in Ni or x in massT or x == '.']
    #             if ''.join(v) == j:
    #                 r0.append(j)
    #         if len(r0) != 0:
    #             r.append([lst[i][0], r0])
    # else:
    #     r = lst
    # Ni.remove('.')
    # return Ni, r


rez, rooles, flag = check_KS()
print('1)', rez)
if flag == True:
    rez = check_exist(rooles, massT, S)
    print('2)', rez)

print('Исходная грамматика:')
print('G = (', massT, ',', massN, ', P,', S, ')')
print("\n".join(f"{i[0]} -> {' '.join(i[1])}" for i in rooles))

print('Эквивалентное преобразование грамматики посредству удаления:')

massN1, rooles1 = del_useless_sym(massT, massN, rooles)
print('G = (', massT, ',', massN1, ', P,', S, ')')
print("\n".join(f"{i[0]} -> {' '.join(i[1])}" for i in rooles1))
